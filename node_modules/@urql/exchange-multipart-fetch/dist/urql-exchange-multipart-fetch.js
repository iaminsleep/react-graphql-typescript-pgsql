Object.defineProperty(exports, '__esModule', {
  value: true
});

var wonka = require('wonka');

var extractFiles = require('extract-files');

var internal = require('@urql/core/internal');

var multipartFetchExchange = ({
  forward,
  dispatchDebug
}) => ops$ => {
  var sharedOps$ = wonka.share(ops$);
  var fetchResults$ = wonka.mergeMap(operation => {
    var teardown$ = wonka.filter(op => op.kind === 'teardown' && op.key === operation.key)(sharedOps$); // Spreading operation.variables here in case someone made a variables with Object.create(null).

    var {
      files,
      clone: variables
    } = extractFiles.extractFiles({ ...operation.variables
    });
    var body = internal.makeFetchBody({
      query: operation.query,
      variables
    });
    var url;
    var fetchOptions;

    if (files.size) {
      url = internal.makeFetchURL(operation);
      fetchOptions = internal.makeFetchOptions(operation);

      if (fetchOptions.headers['content-type'] === 'application/json') {
        delete fetchOptions.headers['content-type'];
      }

      fetchOptions.method = 'POST';
      fetchOptions.body = new FormData();
      fetchOptions.body.append('operations', JSON.stringify(body));
      var map = {};
      var i = 0;
      files.forEach(paths => {
        map[++i] = paths.map(path => `variables.${path}`);
      });
      fetchOptions.body.append('map', JSON.stringify(map));
      i = 0;
      files.forEach((_, file) => {
        fetchOptions.body.append(`${++i}`, file, file.name);
      });
    } else {
      url = internal.makeFetchURL(operation, body);
      fetchOptions = internal.makeFetchOptions(operation, body);
    }

    process.env.NODE_ENV !== 'production' ? dispatchDebug({
      type: 'fetchRequest',
      message: 'A fetch request is being executed.',
      operation,
      data: {
        url,
        fetchOptions
      },
      "source": "multipartFetchExchange"
    }) : undefined;
    return wonka.onPush(result => {
      var error = !result.data ? result.error : undefined;
      process.env.NODE_ENV !== 'production' ? dispatchDebug({
        type: error ? 'fetchError' : 'fetchSuccess',
        message: `A ${error ? 'failed' : 'successful'} fetch response has been returned.`,
        operation,
        data: {
          url,
          fetchOptions,
          value: error || result
        },
        "source": "multipartFetchExchange"
      }) : undefined;
    })(wonka.takeUntil(teardown$)(internal.makeFetchSource(operation, url, fetchOptions)));
  })(wonka.filter(operation => {
    return operation.kind === 'query' || operation.kind === 'mutation';
  })(sharedOps$));
  var forward$ = forward(wonka.filter(operation => {
    return operation.kind !== 'query' && operation.kind !== 'mutation';
  })(sharedOps$));
  return wonka.merge([fetchResults$, forward$]);
};

exports.multipartFetchExchange = multipartFetchExchange;
//# sourceMappingURL=urql-exchange-multipart-fetch.js.map
